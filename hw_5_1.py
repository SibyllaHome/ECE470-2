
# coding: utf-8

# In[3]:


import numpy as np
from numpy.linalg import inv, norm
from scipy.linalg import expm, logm
from ece470_lib import *


# In[4]:


#1


# In[5]:


p_1 = np.array([[0.8376], [-0.2271], [-2.2027]])
p_2 = np.array([[1.9970], [-0.6352], [-3.5119]])
r_1 = 1.2090
r_2 = 0.9599


# In[6]:


def sphere_collision(p1, r1, p2, r2):
    return norm(p1 - p2) <= (r1+r2)


# In[7]:


sphere_collision(p_1, r_1, p_2, r_2)


# In[8]:


#2


# In[9]:


p = np.array([[-4.1261, 4.5113, -3.9566, -0.9634, 3.3128, -3.0713, -2.0789, 0.3653,  4.8274, -0.8303, -0.5655, 1.9194, 3.2100], [3.2698, 4.8948, 0.3046, 4.8106, -4.2032, -4.3297, -0.0951, -3.2969,  2.4222, -3.6314, 2.6217, -2.8653, 3.8672], [-2.9576, -0.8028, -3.2243, -3.8770, 4.8465, 2.1210, 4.4067, 0.7208,  4.9217, 1.9866, 4.0298, 0.3018, -3.9634]])
r = np.array([[2.1644, 2.8588, 1.4721, 1.1304, 1.5043, 2.4329, 1.5606, 2.6372, 2.7402,  1.4939, 2.6892, 1.9464, 2.9410]])
q = np.array([[2.5073], [-0.1181], [-1.1757]])
s = 2.5847


# In[10]:


def multi_sphere_collision(p, r, q, s):
    N = p.shape[1]
    p = np.hsplit(p, N)
    r = np.hsplit(r, N)
    return 1*np.reshape([sphere_collision(p1, r1, q, s) for p1, r1 in zip(p, r)], (1,N))
    


# In[11]:


multi_sphere_collision(p, r, q, s)


# In[12]:


#3


# In[101]:


S = np.array([[ 0,  0,  0,  1,  0,  1], [ 0, -1, -1,  0, -1,  0], [-1,  0,  0,  0,  0,  0], [ 0, -2, -4,  0, -4,  0], [ 0,  0,  0, -4,  0, -2], [ 0,  2,  2,  0, -2,  0]])
M = np.array([[ 1,  0,  0,  4], [ 0,  0, -1,  0], [ 0,  1,  0, -2], [ 0,  0,  0,  1]])
theta = np.array([[2.67372697], [1.32667109], [2.58320973], [1.64305475], [-3.07059281], [0.58241039]])


# In[102]:


P = np.asarray([[0,0,0],[0,0,-2],[-2,0,-2],[-2,0,-4],[0,0,-4],[2,0,-4],[2,0,-2],[4,0,-2]]).T


# In[103]:


def transform_pts(P, S, theta, M):
    N = S.shape[1]
    S = np.hsplit(S,N)
    P = np.hsplit(P,P.shape[1])
    T = toTs(S, theta)
    ret = []
    T.insert(0, np.identity(4))
    T.insert(0, np.identity(4))
    for i in range(len(T)):
        temp = np.identity(4)
        for t in T[:i+1]:
            temp = temp.dot(t)
        ret.append(temp.dot(np.vstack([ P[i] , [[1]]])))
    return np.hstack(ret)[:3]


# In[104]:


P


# In[105]:


transform_pts(P, S , theta, M)


# In[18]:


N = S.shape[1]
S = np.hsplit(S,N)
P = np.hsplit(P,P.shape[1])
T = toTs(S, theta)
ret = []
T.insert(0, np.identity(4))
for i in range(len(T)):
    temp = np.identity(4)
    for t in T[:i+1]:
        temp = temp.dot(t)
    ret.append(temp.dot( np.vstack([P[i], [[1]]])))


# In[19]:


ret[0]


# In[20]:


#4


# In[21]:


S = np.array([[ 0,  0,  0,  0,  0,  0], [ 1,  0,  0, -1, -1,  0], [ 0,  0,  0,  0,  0,  0], [ 2,  0,  0,  2,  4,  1], [ 0,  0,  0,  0,  0,  0], [ 0,  1,  1,  0,  0,  0]])
M = np.array([[ 1,  0,  0,  0], [ 0, -1,  0, -4], [ 0,  0, -1,  4], [ 0,  0,  0,  1]])
theta = np.array([[-0.47213722], [0.75115094], [1.43729751], [0.08648080], [0.96325132], [0.81998623]])
r = 0.90000000


# In[71]:


P = np.atleast_2d([[0,0,0],[0,0,-2],[0,4,-2],[0,4,0],[0,4,2],[0,2,4],[0,-2,4],[0,-4,4]]).T


# In[23]:


locs = np.hsplit(transform_pts(P, S , theta, M),8)


# In[24]:


1*np.asarray([[sphere_collision(l1, r, l2, r) for l2 in locs] for l1 in locs])- np.identity(8)


# In[25]:


#5


# In[139]:


S = np.array([[ 0,  0,  1,  0,  0,  0], [ 1,  0,  0,  1,  0,  0], [ 0,  0,  0,  0,  1,  0], [ 2,  1,  0,  0,  8,  0], [ 0,  0,  0,  0,  0,  0], [ 0,  0, -4,  0,  0, -1]])
M = np.array([[ 0,  1,  0,  0], [ 1,  0,  0, 10], [ 0,  0, -1, -2], [ 0,  0,  0,  1]])
theta = np.array([[-0.74337378, -0.07695044, -0.37437736, 0.96310740, 1.01532127,  -0.37610945, -1.65875066, 0.96136696, 0.12337690, 3.01470180,  -1.73470253, 2.81130419, -1.10992522, -2.33964104, -2.33624227,  2.66968056, 2.51713295, -1.06638429, -1.54017429, -2.90874752], [-0.16426936, 0.53206337, 1.91951160, 0.03560386, 1.99205858,  -0.15218103, -2.78614725, 2.60908321, -2.49510494, 2.55215085,  -3.08306690, 0.97564183, -1.71369700, 2.57114703, 2.63711428,  1.91543637, -2.82134723, -2.80966732, 0.91632565, 2.14633225], [-2.31887371, 1.76737377, -1.44432160, 1.80196459, 0.00431988,  0.12892306, 1.31875393, 1.64965195, -2.30951688, -1.18831222,  -2.16587000, 0.60607764, -0.19120847, -0.39452011, -1.51674437,  -0.56210527, 1.06615808, -0.59233555, 1.58733003, 0.41460294], [1.34475070, -2.00428000, 2.11983930, 3.11708237, -1.54945760,  -2.64419445, -2.23157400, 1.19529334, 1.16056503, -0.54550935,  0.64953169, 2.47947627, -2.26404806, 1.40050686, -3.04869485,  2.06671820, 1.35728661, 2.61359441, -0.53342615, -2.07887638], [1.83650730, 1.53255724, -2.66096010, -0.14535447, -1.55552874,  -1.84137355, -1.60534770, -1.70950667, -0.99273476, -2.85855308,  1.19258911, 2.57250345, -0.20064242, 1.22992971, 3.03441677,  -0.90344475, 2.11044861, -2.11733825, -0.89468793, -2.41139908], [1.11976636, 2.77112653, 1.56142560, 1.36139845, 0.07475837, -1.42338105,  1.59758941, 2.07567897, -1.14090224, 0.20822857, 1.07610998,  -3.07838835, -0.36458856, 0.05703633, -1.31853526, 0.84217482,  0.51455656, -2.32392537, -1.68526445, -0.30245917]])
r = 0.90000000


# In[140]:


P = np.array([[0,0,0],[0,0,-2],[0,4,-2],[0,4,0],[0,6,0],[0,8,0],[0,10,0],[0,10,-2]]).T


# In[141]:


t2 = np.hsplit(theta, 20)
tpts = [np.hsplit(transform_pts(P, S, t, M),8) for t in t2]


# In[142]:


1*np.atleast_2d([0 < np.sum(1*[[norm(p1 - p2) <  2*r for p1 in p] for p2 in p]-np.identity(8)) for p in tpts])


# In[115]:


tpts[0]


# In[80]:


P.shape


# In[81]:


P


# In[91]:




